"use strict";

var _classProps = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _extends = function (child, parent) {
  child.prototype = Object.create(parent.prototype, {
    constructor: {
      value: child,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  child.__proto__ = parent;
};

var Node = require("./node");
var Declaration = require("./declaration");

// CSS node, that contain another nodes (like at-rules or rules with selectors)
var Container = (function (Node) {
  var Container = function Container() {
    Node.apply(this, arguments);
  };

  _extends(Container, Node);

  Container.prototype.styleMap = function () {
    var style = {
      beforeRule: this.before,
      beforeOpen: this.between
    };
    if (this.childs && this.childs.length) {
      style.beforeClose = this.after;
    } else {
      style.emptyBody = this.after;
    }
    return style;
  };

  Container.prototype.stringifyContent = function (builder) {
    if (!this.childs) return;

    var i, last = this.childs.length - 1;
    while (last > 0) {
      if (this.childs[last].type != "comment") break;
      last -= 1;
    }

    for (i = 0; i < this.childs.length; i++) {
      this.childs[i].stringify(builder, last != i || this.semicolon);
    }
  };

  Container.prototype.stringifyBlock = function (builder, start) {
    var before = this.style("beforeRule");
    if (before) builder(before);
    builder(start + this.style("beforeOpen") + "{", this, "start");

    var after;
    if (this.childs && this.childs.length) {
      this.stringifyContent(builder);
      after = this.style("beforeClose");
    } else {
      after = this.style("emptyBody");
    }

    if (after) builder(after);
    builder("}", this, "end");
  };

  Container.prototype.push = function (child) {
    child.parent = this;
    this.childs.push(child);
    return this;
  };

  Container.prototype.each = function (callback) {
    if (!this.lastEach) this.lastEach = 0;
    if (!this.indexes) this.indexes = {};

    this.lastEach += 1;
    var id = this.lastEach;
    this.indexes[id] = 0;

    if (!this.childs) return;

    var index, result;
    while (this.indexes[id] < this.childs.length) {
      index = this.indexes[id];
      result = callback(this.childs[index], index);
      if (result === false) break;

      this.indexes[id] += 1;
    }

    delete this.indexes[id];

    if (result === false) return false;
  };

  Container.prototype.eachInside = function (callback) {
    return this.each(function (child, i) {
      var result = callback(child, i);

      if (result !== false && child.eachInside) {
        result = child.eachInside(callback);
      }

      if (result === false) return result;
    });
  };

  Container.prototype.eachDecl = function (callback) {
    return this.eachInside(function (child, i) {
      if (child.type == "decl") {
        var result = callback(child, i);
        if (result === false) return result;
      }
    });
  };

  Container.prototype.eachRule = function (callback) {
    return this.eachInside(function (child, i) {
      if (child.type == "rule") {
        var result = callback(child, i);
        if (result === false) return result;
      }
    });
  };

  Container.prototype.eachAtRule = function (callback) {
    return this.eachInside(function (child, i) {
      if (child.type == "atrule") {
        var result = callback(child, i);
        if (result === false) return result;
      }
    });
  };

  Container.prototype.eachComment = function (callback) {
    return this.eachInside(function (child, i) {
      if (child.type == "comment") {
        var result = callback(child, i);
        if (result === false) return result;
      }
    });
  };

  Container.prototype.append = function (child) {
    var childs = this.normalize(child, this.last);
    for (var i = 0; i < childs.length; i++) {
      this.childs.push(childs[i]);
    }
    return this;
  };

  Container.prototype.prepend = function (child) {
    var childs = this.normalize(child, this.first, "prepend").reverse();
    for (var i = 0; i < childs.length; i++) {
      this.childs.unshift(childs[i]);
    }

    for (var id in this.indexes) {
      this.indexes[id] = this.indexes[id] + childs.length;
    }

    return this;
  };

  Container.prototype.insertBefore = function (exist, add) {
    exist = this.index(exist);

    var type = exist === 0 ? "prepend" : false;
    var childs = this.normalize(add, this.childs[exist], type).reverse();
    for (var i = 0; i < childs.length; i++) {
      this.childs.splice(exist, 0, childs[i]);
    }

    var index;
    for (var id in this.indexes) {
      index = this.indexes[id];
      if (exist <= index) {
        this.indexes[id] = index + childs.length;
      }
    }

    return this;
  };

  Container.prototype.insertAfter = function (exist, add) {
    exist = this.index(exist);

    var childs = this.normalize(add, this.childs[exist]).reverse();
    for (var i = 0; i < childs.length; i++) {
      this.childs.splice(exist + 1, 0, childs[i]);
    }

    var index;
    for (var id in this.indexes) {
      index = this.indexes[id];
      if (exist < index) {
        this.indexes[id] = index + childs.length;
      }
    }

    return this;
  };

  Container.prototype.remove = function (child) {
    child = this.index(child);
    this.childs.splice(child, 1);

    var index;
    for (var id in this.indexes) {
      index = this.indexes[id];
      if (index >= child) {
        this.indexes[id] = index - 1;
      }
    }

    return this;
  };

  Container.prototype.every = function (condition) {
    return this.childs.every(condition);
  };

  Container.prototype.some = function (condition) {
    return this.childs.some(condition);
  };

  Container.prototype.index = function (child) {
    if (typeof (child) == "number") {
      return child;
    } else {
      return this.childs.indexOf(child);
    }
  };

  Container.prototype.normalize = function (child, sample) {
    if (!child.type && !Array.isArray(child)) {
      child = new Declaration(child);
    }

    var childs;
    if (child.type == "root") {
      childs = child.childs;
    } else if (Array.isArray(child)) {
      childs = child.map(function (i) {
        return i.clone();
      });
    } else {
      if (child.parent) {
        child = child.clone();
      }
      childs = [child];
    }

    for (var i = 0; i < childs.length; i++) {
      child = childs[i];
      child.parent = this;
      if (typeof (child.before) == "undefined" && sample) {
        child.before = sample.before;
      }
    }

    return childs;
  };

  _classProps(Container, null, {
    first: {
      // Shortcut to get first child
      get: function () {
        if (!this.childs) return undefined;
        return this.childs[0];
      }
    },
    last: {
      // Shortcut to get first child
      get: function () {
        if (!this.childs) return undefined;
        return this.childs[this.childs.length - 1];
      }
    }
  });

  return Container;
})(Node);

["rules", "decls", "list"].forEach(function (name) {
  Object.defineProperty(Container.prototype, name, {
    get: function () {
      if (console && console.warn) {
        console.warn("Property " + name + " has been deprecated and " + "will be removed in 3.1. Use childs instead.");
      }
      return this.childs;
    }
  });
});

module.exports = Container;